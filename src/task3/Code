#!/usr/bin/env python3
import rclpy    # Needed to create a ROS node
import numpy as np

from rclpy.node import Node
from geometry_msgs.msg import Twist
from std_msgs.msg import String
from pynput import keyboard
from turtlesim.msg import Pose
from turtlesim.srv import Spawn

class TurtleSwarmNode(Node):
    def __init__(self):
        super().__init__('turtle_swarm_node')

        self.cli = self.create_client(Spawn, 'spawn')
        while not self.cli.wait_for_service(timeout_sec=1.0):
             self.get_logger().info('service not available, waiting again...')
        self.req = Spawn.Request()
       
        response2= self.spawn_new_turtle(4.0, 4.0, 0.0, 'turtle2')
        response3 = self.spawn_new_turtle(6.0, 6.0, 0.0, 'turtle3')
        response4 = self.spawn_new_turtle(5.0, 5.0, 0.0, 'turtle4')
        response5 = self.spawn_new_turtle(2.0, 6.0, 0.0, 'turtle5')
        if response2.name:
            self.get_logger().info(f'Successfully spawned turtle: {response2.name}')
        else:
            self.get_logger().error('Failed to spawn turtle.')

        self.cmd_vel_pub_2 = self.create_publisher(Twist,"/turtle2/cmd_vel",40)
        self.subscription2 = self.create_subscription(Pose,'/turtle2/pose',self.pose_callback2,10)
        self.timer2 = self.create_timer(1.0, self.send_velocity_command2)

        self.cmd_vel_pub_3 = self.create_publisher(Twist,"/turtle3/cmd_vel",40)
        self.timer3 = self.create_timer(2.0, self.send_velocity_command3)

        self.cmd_vel_pub_4 = self.create_publisher(Twist,"/turtle4/cmd_vel",40)
        self.timer4 = self.create_timer(3.0, self.send_velocity_command4)

        self.cmd_vel_pub_5 = self.create_publisher(Twist,"/turtle5/cmd_vel",40)
        self.timer5 = self.create_timer(4.0, self.send_velocity_command5)

        #self.send_velocity_command()
        self.get_logger().info('Move circle node has been started')
        self.counter=0
        self.publisher_ = self.create_publisher(String, 'keypress_topic', 10)
        self.listener = keyboard.Listener(
                on_press=self.on_press,
                on_release=self.on_release)
        self.listener.start()

       
    def send_velocity_command2(self):
        msg=Twist()
        msg.linear.x=np.pi
        msg.linear.y=0.0
        msg.linear.z=0.0
        msg.angular.x=0.0
        msg.angular.y=0.0
        msg.angular.z=np.pi/2.0
        self.cmd_vel_pub_2.publish(msg)
        self.counter+=1
        #self.pose_callback()

        if(self.counter>=4) :
            self.get_logger().info('Press f key to move forward to the next point on the circle')
            self.timer2.cancel()

    def send_velocity_command3(self):
        msg=Twist()
        msg.linear.x=np.pi
        msg.linear.y=0.0
        msg.linear.z=0.0
        msg.angular.x=0.0
        msg.angular.y=0.0
        msg.angular.z=np.pi/2.0
        self.cmd_vel_pub_3.publish(msg)

    def send_velocity_command4(self):
        msg=Twist()
        msg.linear.x=np.pi
        msg.linear.y=0.0
        msg.linear.z=0.0
        msg.angular.x=0.0
        msg.angular.y=0.0
        msg.angular.z=np.pi/2.0
        self.cmd_vel_pub_4.publish(msg)

    def send_velocity_command5(self):
        msg=Twist()
        msg.linear.x=np.pi
        msg.linear.y=0.0
        msg.linear.z=0.0
        msg.angular.x=0.0
        msg.angular.y=0.0
        msg.angular.z=np.pi/2.0
        self.cmd_vel_pub_5.publish(msg)

    def pose_callback2(self, msg):
        self.current_pose = msg
        self.get_logger().info(f'Turtle2 position: x={msg.x:.2f}, y={msg.y:.2f}, theta={msg.theta:.2f}')

    def on_press(self, key):
        try:
            key_char = key.char
        except AttributeError:
            key_char = str(key) # Handle special keys like 'space', 'esc', etc.

        msg = String()
        msg.data = f"Pressed: {key_char}"
        self.publisher_.publish(msg)
        if (key_char=='f'):
            self.timer2.reset()
        self.get_logger().info(f'Publishing: "{msg.data}"')

    def on_release(self, key):
        # Optional: handle key release events
        pass
   
    def spawn_new_turtle(self, x, y, theta, name):
        self.req.x = x
        self.req.y = y
        self.req.theta = theta
        self.req.name = name
        self.future = self.cli.call_async(self.req)
        rclpy.spin_until_future_complete(self, self.future)
        return self.future.result()    
   
def main(args=None):
    rclpy.init(args=args)
    node=TurtleSwarmNode()

    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
